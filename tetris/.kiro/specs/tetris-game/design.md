# 設計ドキュメント

## 概要

ブラウザで動作するテトリスゲームは、HTML5 Canvas、JavaScript（またはTypeScript）、CSSを使用して実装されます。ゲームは、ゲームロジック、レンダリング、入力処理を分離したモジュラーアーキテクチャを採用します。

## アーキテクチャ

システムは以下の主要コンポーネントで構成されます：

```
┌─────────────────────────────────────┐
│         UI Layer (HTML/CSS)         │
│  - Canvas Element                   │
│  - Control Buttons                  │
│  - Score Display                    │
└─────────────────────────────────────┘
              ↓ ↑
┌─────────────────────────────────────┐
│       Game Controller               │
│  - Game Loop                        │
│  - Input Handler                    │
│  - State Manager                    │
└─────────────────────────────────────┘
              ↓ ↑
┌─────────────────────────────────────┐
│       Game Logic Layer              │
│  - Board Manager                    │
│  - Tetromino Manager                │
│  - Collision Detector               │
│  - Line Clearer                     │
│  - Score Calculator                 │
└─────────────────────────────────────┘
              ↓ ↑
┌─────────────────────────────────────┐
│       Renderer                      │
│  - Canvas Renderer                  │
└─────────────────────────────────────┘
```

## コンポーネントとインターフェース

### 1. Tetromino

テトリミノの形状、位置、回転状態を管理します。

```typescript
interface Position {
  x: number;
  y: number;
}

interface Tetromino {
  type: 'I' | 'O' | 'T' | 'S' | 'Z' | 'J' | 'L';
  shape: number[][];  // 2D配列で形状を表現
  position: Position;
  color: string;
}
```

### 2. Board

ゲームボードの状態を管理します。

```typescript
interface Board {
  grid: (string | null)[][];  // 10x20のグリッド、色またはnull
  width: number;   // 10
  height: number;  // 20
}
```

### 3. GameState

ゲーム全体の状態を管理します。

```typescript
interface GameState {
  board: Board;
  activeTetromino: Tetromino | null;
  nextTetromino: Tetromino;
  score: number;
  level: number;
  isPlaying: boolean;
  isPaused: boolean;
  isGameOver: boolean;
}
```

### 4. GameController

ゲームのメインロジックを制御します。

```typescript
class GameController {
  startGame(): void;
  pauseGame(): void;
  resumeGame(): void;
  resetGame(): void;
  update(deltaTime: number): void;
  moveLeft(): boolean;
  moveRight(): boolean;
  moveDown(): boolean;
  rotate(): boolean;
}
```

### 5. CollisionDetector

衝突検出を行います。

```typescript
class CollisionDetector {
  checkCollision(tetromino: Tetromino, board: Board): boolean;
  canMove(tetromino: Tetromino, dx: number, dy: number, board: Board): boolean;
  canRotate(tetromino: Tetromino, board: Board): boolean;
}
```

### 6. LineClearer

完全なラインを検出して削除します。

```typescript
class LineClearer {
  findCompleteLines(board: Board): number[];
  clearLines(board: Board, lines: number[]): void;
  calculateScore(linesCleared: number): number;
}
```

## データモデル

### テトリミノの形状定義

各テトリミノは4x4のグリッドで定義されます：

```typescript
const TETROMINOS = {
  I: {
    shape: [
      [0, 0, 0, 0],
      [1, 1, 1, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0]
    ],
    color: '#00f0f0'
  },
  O: {
    shape: [
      [1, 1],
      [1, 1]
    ],
    color: '#f0f000'
  },
  T: {
    shape: [
      [0, 1, 0],
      [1, 1, 1],
      [0, 0, 0]
    ],
    color: '#a000f0'
  },
  // ... 他のテトリミノ
};
```

### 回転ロジック

テトリミノの回転は、形状配列を90度時計回りに転置することで実現します。

```typescript
function rotateMatrix(matrix: number[][]): number[][] {
  const n = matrix.length;
  const rotated = Array(n).fill(0).map(() => Array(n).fill(0));
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      rotated[j][n - 1 - i] = matrix[i][j];
    }
  }
  return rotated;
}
```


## 正確性プロパティ

*プロパティとは、システムのすべての有効な実行において真であるべき特性または動作です。本質的には、システムが何をすべきかについての形式的な記述です。プロパティは、人間が読める仕様と機械で検証可能な正確性保証との橋渡しとなります。*

### プロパティリフレクション

事前作業分析を確認した結果、以下の冗長性を特定しました：

- プロパティ1（左移動）とプロパティ2（右移動）は、方向パラメータを持つ単一の「移動プロパティ」に統合できます
- プロパティ3.1（ライン削除）とプロパティ3.2（ブロック移動）は密接に関連しており、「ライン削除の不変性」として統合できます

### テスト可能なプロパティ

**プロパティ1: テトリミノの移動の一貫性**
*任意の*有効なテトリミノと位置、および方向（左、右、下）について、衝突がない場合、移動操作は位置を正確に1マス指定された方向に変更する必要があります
**検証: 要件 1.1, 1.2**

**プロパティ2: 回転の形状保存**
*任意の*テトリミノについて、4回連続で回転すると元の形状に戻る必要があります
**検証: 要件 1.3**

**プロパティ3: 衝突時の位置不変性**
*任意の*テトリミノとボード状態について、衝突が発生する移動または回転を試みた場合、テトリミノの位置と形状は変更されない必要があります
**検証: 要件 1.5**

**プロパティ4: テトリミノのロック後の生成**
*任意の*ボード状態について、アクティブなテトリミノがロックされた後、新しいアクティブなテトリミノが生成される必要があります
**検証: 要件 2.3**

**プロパティ5: 完全なラインの削除と重力**
*任意の*ボード状態について、完全なラインが削除された後、削除されたラインより上のすべてのブロックは正確に削除されたライン数だけ下に移動し、ボードの総ブロック数は削除されたライン分だけ減少する必要があります
**検証: 要件 3.1, 3.2**

**プロパティ6: スコアの単調性**
*任意の*ライン削除について、削除されたライン数が多いほど、付与されるスコアは高くなる必要があります（1ライン < 2ライン < 3ライン < 4ライン）
**検証: 要件 3.3, 3.4**

**プロパティ7: 一時停止のトグル動作**
*任意の*ゲーム状態について、一時停止操作を2回連続で実行すると、元の再生/一時停止状態に戻る必要があります
**検証: 要件 5.2**

**プロパティ8: 一時停止中の状態不変性**
*任意の*一時停止中のゲーム状態について、時間が経過してもボード状態、アクティブなテトリミノの位置、スコアは変更されない必要があります
**検証: 要件 5.3**

**プロパティ9: テトリミノ生成のランダム性**
*十分に大きな*サンプル数（例：1000回）について、各テトリミノタイプ（I、O、T、S、Z、J、L）が生成される確率は、統計的に均等である必要があります（各タイプが約14.3%）
**検証: 要件 6.2**

**プロパティ10: 回転後の形状整合性**
*任意の*テトリミノタイプについて、回転後の形状は、そのテトリミノタイプの有効な回転状態のいずれかと一致する必要があります
**検証: 要件 6.4**

### エッジケース

以下のエッジケースは、プロパティベーステストのジェネレータで処理されます：

- **ゲームオーバー条件**: 新しいテトリミノが生成位置に配置できない場合（要件 2.4）
- **ボード境界**: テトリミノがボードの端にある場合の移動と回転
- **複数ライン削除**: 1〜4ラインの同時削除

## エラーハンドリング

### 入力検証

- 無効なキー入力は無視されます
- ゲームが一時停止中またはゲームオーバー状態の場合、移動コマンドは無視されます

### 状態管理

- ゲーム状態の遷移は明確に定義されます：
  - 未開始 → プレイ中 → 一時停止 → プレイ中 → ゲームオーバー
- 無効な状態遷移は防止されます

### レンダリングエラー

- Canvas要素が利用できない場合、エラーメッセージを表示します
- レンダリング中のエラーは、ゲームの進行を停止せずにコンソールに記録します

## テスト戦略

### 単体テスト

単体テストは以下をカバーします：

- **テトリミノの形状定義**: 各テトリミノタイプが正しい形状と色を持つことを確認
- **回転ロジック**: 回転行列の変換が正しいことを確認
- **衝突検出**: 特定のシナリオ（壁、床、他のブロック）での衝突検出
- **ライン削除**: 特定のボード状態でのライン検出と削除
- **スコア計算**: 1〜4ラインの削除に対する正しいスコア計算
- **ゲーム状態遷移**: 開始、一時停止、再開、ゲームオーバーの遷移

### プロパティベーステスト

プロパティベーステストライブラリとして**fast-check**（JavaScript/TypeScript用）を使用します。

**設定要件**:
- 各プロパティベーステストは最低100回の反復を実行する必要があります
- 各テストは、実装する正確性プロパティを明示的に参照するコメントでタグ付けする必要があります
- タグ形式: `// Feature: tetris-game, Property X: [プロパティテキスト]`

**テスト対象のプロパティ**:

1. **移動の一貫性**: ランダムなテトリミノ、位置、ボード状態を生成し、有効な移動が正しく位置を変更することを確認
2. **回転の形状保存**: ランダムなテトリミノを生成し、4回回転後に元の形状に戻ることを確認
3. **衝突時の不変性**: ランダムなボード状態とテトリミノを生成し、無効な移動が状態を変更しないことを確認
4. **ロック後の生成**: ランダムなボード状態でテトリミノをロックし、新しいテトリミノが生成されることを確認
5. **ライン削除の不変性**: ランダムなボード状態を生成し、ライン削除後のブロック数と位置が正しいことを確認
6. **スコアの単調性**: 異なるライン数でスコアが単調増加することを確認
7. **一時停止のトグル**: ランダムなゲーム状態で一時停止を2回実行し、元の状態に戻ることを確認
8. **一時停止中の不変性**: 一時停止中のゲーム状態で時間を進め、状態が変更されないことを確認
9. **ランダム生成の均等性**: 大量のテトリミノを生成し、各タイプの出現頻度が統計的に均等であることを確認
10. **回転後の整合性**: ランダムなテトリミノを回転し、結果が有効な形状であることを確認

### 統合テスト

- ゲーム全体のフロー（開始からゲームオーバーまで）をテストします
- キーボード入力からレンダリングまでの完全なパイプラインをテストします

### 手動テスト

- ブラウザでの視覚的な確認（要件4.1〜4.5）
- ユーザーエクスペリエンスの評価
- パフォーマンスの確認

## 実装の考慮事項

### パフォーマンス

- ゲームループは`requestAnimationFrame`を使用して60FPSを目指します
- レンダリングは変更があった場合のみ実行します（ダーティフラグパターン）

### ブラウザ互換性

- モダンブラウザ（Chrome、Firefox、Safari、Edge）をサポートします
- Canvas APIとES6+の機能を使用します

### コードの構造

- モジュラーな設計により、各コンポーネントは独立してテスト可能です
- 純粋関数を優先し、副作用を最小限に抑えます
- TypeScriptを使用して型安全性を確保します（オプション）

## 将来の拡張

- レベルシステム（速度の増加）
- ハードドロップ機能
- ゴーストピース（落下位置のプレビュー）
- ハイスコアの保存（LocalStorage）
- サウンドエフェクトと音楽
- モバイル対応（タッチ操作）
